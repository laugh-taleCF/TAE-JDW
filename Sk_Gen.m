function [sk_a,sk_w] = Sk_Gen(G,M_D,A,T,L,len_skm,R)

    sk_a = zeros(M_D*R,1);                   % 总密钥向量，加密密钥是一个长度为M_D*R的列向量,用于选择主加密表中的条目
    sk_w = zeros(len_skm*R,1);               % 子集密钥向量，提取水印密钥是一个长度为len_skm*R的列向量，用于选择水印表中的条目，有len_skm个秘密水印投影方向，M_D是总投影方向
    
    % 初始化索引指针（k对应A的索引，h对应G的列索引）
    k = 1;                                   % 指向A中当前处理的元素
    h = 1;                                   % 指向G中当前使用的列
    
    % 遍历所有M_D个索引
    for i = 1:M_D
                                             % 若当前索引i是A中的元素（即属于选中的子集），是要嵌入水印的索引位
        if i == A(k)                         % 这里的A是前面S_Gen_Audio.m函数用来存储水印投影索引的，它经过了sort增序排序
                                             % 找到G的第h列中值为1的位置（作为密钥来源），G的大小为T*L
            source = find(G(:,h)==1);        % G(:,h)表示第h各列向量，G(:,h)==1生成的是一个跟原来等长的列向量，取值为原元素和1取==的布尔值，find则是将该列向量中非0的索引取出来组合成一个新向量
            % 随机打乱来源位置的顺序，G就是用来生成水印密钥的
            ind = randperm(length(source));
            
            % 为当前索引生成R个密钥元素，G的每一列1的个数都是大于等于R的
            for j = 1:R
                % 填充sk_a和sk_w（两者在对应位置取值相同）
                sk_a((i-1)*R + j) = source(j);  % sk_a的第(i-1)*R+j位置，因为加密，解密和水印嵌入都是使用的主加密密，水印嵌入是L个方向，在这L个方向，水印密钥和加密密钥一样就可以了
                sk_w((k-1)*R + j) = source(j);  % sk_w的第(k-1)*R+j位置，反正这里能够保证提取的水印密钥和加密时相同，实际上解密到水印方向时，就是用水印密钥来嵌入水印的
            end
            
            % 更新指针（处理下一个A中的元素），水印密钥比主加密密钥更短，一个长度是M_D*R,另一个是len_skm*R,len_skm是秘密水印投影方向，L是水印的比特数
            if k < len_skm
                k = k + 1;                      % 移动到A的下一个元素
                % 移动G的列索引（若未超过L则递增，否则随机选一列）
                if h < L
                    h = h + 1;
                else
                    h = ceil(rand()*L);         % 随机生成1到L的整数
                end
            end
        else
            % 若当前索引i不在A中，生成值为1到T的长度为R的随机排列作为密钥，sk_a加密密钥的大小为M_D*R
            sk_a((i-1)*R + 1 : i*R) = randperm(T,R);
        end
    end
    
end